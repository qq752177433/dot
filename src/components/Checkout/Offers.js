import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import styled from 'styled-components';
import classnames from 'classnames';
import queryString from 'query-string';
import _ from 'lodash';
import Web3Utils from 'web3-utils';
import etherscanLink from '../../vendor/etherscan-link';
import LaddaButton, { XL, EXPAND_RIGHT } from 'react-ladda';
const BN = Web3Utils.BN;
import 'ladda/dist/ladda-themeless.min.css';

import * as Web3 from '../../redux/web3';
import * as Config from '../../redux/config';
import * as Shop from '../../redux/shop';
import theme from '../../styles/theme';
import { FormStyles } from '../../styles/forms';

class Offers extends Component {
  constructor(props, context) {
    super(props);

    this.state = {
      assignee: context.assignee || '',
      affiliate: context.affiliate || '',
      assigneeDirty: false,
      errors: {},
      warnings: {}
      // submitting: false
    };

    this.onOfferSelected = this.onOfferSelected.bind(this);
    this.onAssigneeChanged = this.onAssigneeChanged.bind(this);
    this.onPayButtonPressed = this.onPayButtonPressed.bind(this);
  }

  componentWillMount() {
    this.configureOfferings();

    if (!_.isEmpty(this.state.assignee)) {
      this.onAssigneeChanged({ target: { value: this.state.assignee } });
    }
  }

  componentDidUpdate() {
    this.configureOfferings();
  }

  configureOfferings() {
    let {
      productName,
      productSubheading,
      offerLabel,
      offers,
      logo,
      logo2x,
      products
    } = this.props;

    const offerings = _.map(offers, offer => {
      const product = products[offer.productId];
      if (!product) return;
      const haveInterval = new BN(product.interval).gt(new BN(0));

      const numCycles = haveInterval
        ? new BN(offer.duration).div(new BN(product.interval)).toNumber()
        : 1;
      // TODO -- probably a good idea to assert divisibility here

      const totalPrice = new BN(product.price).mul(new BN(numCycles));

      return {
        ...offer,
        available: parseInt(product.inventory),
        numCycles: numCycles,
        totalPrice
      };
    });
    this.offerings = _.compact(offerings);
  }

  onOfferSelected(event) {
    // this.setState({
    //   ...this.state
    // });
    this.props.setSelectedOfferId(event.target.value);
  }

  onAssigneeChanged(event) {
    const { vanityAddressPrefix, productName } = this.props;
    const assignee = event.target.value;

    const validateAssignee = assignee => {
      const isAddress = Web3Utils.isAddress(assignee);
      if (!isAddress) {
        return {
          message: 'Assignee is not a valid address'
        };
      } else {
        return null;
      }
    };

    let errors = validateAssignee(assignee);

    const warningsAssignee = assignee => {
      const isAddress = Web3Utils.isAddress(assignee);
      if (
        isAddress &&
        vanityAddressPrefix &&
        !(
          _.startsWith(assignee, vanityAddressPrefix) ||
          _.startsWith(assignee, `0x` + vanityAddressPrefix)
        )
      ) {
        return {
          message: (
            <p>
              Warning: An assignee address generated by {productName} should
              normally start with the characters: <tt>{vanityAddressPrefix}</tt>{' '}
              or <tt>0x{vanityAddressPrefix}</tt>
            </p>
          )
        };
      }
    };

    let warnings = warningsAssignee(assignee);

    this.setState({
      ...this.state,
      assignee: assignee,
      assigneeDirty: true,
      errors: {
        ...this.state.errors,
        assignee: errors
      },
      warnings: {
        ...this.state.warnings,
        assignee: warnings
      }
    });
  }

  getSelectedOffering() {
    const { selectedOfferId } = this.props;
    return (
      _.find(this.offerings, offering => offering.id == selectedOfferId) ||
      _.first(this.offerings)
    );
  }

  onPayButtonPressed(event) {
    const offering = this.getSelectedOffering();
    if (offering) {
      this.props.placeOrder(
        offering.productId,
        offering.numCycles,
        this.state.assignee,
        this.state.affiliate,
        offering.totalPrice
      );
    }
  }

  render() {
    let {
      productName,
      productSubheading,
      offerLabel,
      offers,
      logo,
      logo2x,
      selectedOfferId,
      products,
      tosURL,
      helpURL
    } = this.props;

    const offerings = this.offerings;

    const options = _.map(offerings, offering => {
      if (!offering) return;
      let msg = '';
      let disabled = false;
      if (offering.available == 0) {
        msg = ' (out of stock)';
        disabled = true;
      }
      return (
        <option disabled={disabled} key={offering.id} value={offering.id}>
          {offering.name}
          {msg}
        </option>
      );
    });

    const selectedOffering = this.getSelectedOffering();

    const showPrice = selectedOffering
      ? Web3Utils.fromWei(selectedOffering.totalPrice, 'ether').toString()
      : '';

    const assigneeErrors = this.state.errors.assignee ? true : false;
    const assigneeWarnings = this.state.warnings.assignee ? true : false;

    // TODO -- check to make sure the selected product isn't out of stock
    let formValid = true;

    if (assigneeErrors) formValid = false;
    if (_.isEmpty(this.state.assignee)) formValid = false;

    const formInvalid = !formValid;
    const placingOrder = this.props.placingOrder;
    // const placingOrder = true;

    const showInfoMessage =
      this.props.placingOrderMessage || this.props.orderTxHash;

    const transactionUrl = etherscanLink.createExplorerLink(
      this.props.orderTxHash,
      this.props.networkId
    );

    const placingOrderError = _.get(
      this.props,
      ['placingOrderError', 'message'],
      ''
    );
    const placingOrderErrorMsg = placingOrderError.split('\n')[0];

    const selectValue = selectedOfferId || '';

    return (
      <div
        className={classnames(
          this.props.className,
          'form',
          placingOrder ? 'submitting' : null
        )}
      >
        <div className="form-group">
          <label htmlFor="offer">{offerLabel}:</label>
          <select
            name="offer"
            value={selectValue}
            onChange={this.onOfferSelected}
            disabled={placingOrder}
          >
            {options}
          </select>
        </div>
        <div className="form-group">
          <label htmlFor="assignee">{productName} Address:</label>
          <input
            type="text"
            name="assignee"
            placeholder="example: db369c07c8e365aa8fabe5e40a320d35cc350ba2"
            onChange={this.onAssigneeChanged}
            className={classnames(assigneeErrors ? 'error' : null)}
            value={this.state.assignee}
            disabled={placingOrder}
          />

          <div className="muted help">
            <a href={helpURL}>What is a {productName} Address?</a>
          </div>
          {assigneeErrors ? (
            <p className="errorMsg">{this.state.errors.assignee.message}</p>
          ) : null}
          {assigneeWarnings ? (
            <div className="warningMsg">
              {this.state.warnings.assignee.message}
            </div>
          ) : null}
        </div>
        <input type="hidden" name="affiliate" value={this.state.affiliate} />
        {/*
        <div className="inventory">{selectedOffering.available} remaining</div>
 */}
        <div className="form-group last">
          <LaddaButton
            className="pay-button"
            disabled={!formValid}
            onClick={this.onPayButtonPressed}
            loading={this.props.placingOrder}
            data-color="#eee"
            data-size={XL}
            data-style={EXPAND_RIGHT}
            data-spinner-size={30}
            data-spinner-color="#381774"
            data-spinner-lines={12}
          >
            Pay Îž{showPrice}
          </LaddaButton>
        </div>
        {this.props.placingOrderError ? (
          <p className="errorMsg">{placingOrderErrorMsg}</p>
        ) : null}

        {showInfoMessage ? (
          <div className="infoMessage">
            {this.props.placingOrderMessage ? (
              <div className="placingOrderMessage">
                {this.props.placingOrderMessage}
              </div>
            ) : null}
            {this.props.orderTxHash ? (
              <div className="trackTransaction">
                Track your transaction{' '}
                <a href={transactionUrl} target="_blank" rel="external">
                  by clicking here.
                </a>
              </div>
            ) : null}
          </div>
        ) : null}

        <div className="legal">
          By approving this transaction you agree to our{' '}
          <a href={tosURL} target="_blank" rel="external">
            terms of service
          </a>
        </div>
      </div>
    );
  }
}

Offers.contextTypes = {
  affiliate: PropTypes.string,
  assignee: PropTypes.string
};

function mapStateToProps(state, ownProps) {
  let {
    productName,
    productSubheading,
    offerLabel,
    offers,
    logo,
    logo2x,
    tosURL,
    helpURL,
    vanityAddressPrefix
  } = Config.getConfig(state);

  productName = ownProps.productName || productName;
  productSubheading = ownProps.productSubheading || productSubheading;
  offerLabel = ownProps.offerLabel || offerLabel;
  offers = ownProps.offers || offers;
  logo = ownProps.logo || logo;
  logo2x = ownProps.logo2x || logo2x;

  const networkId = Web3.getNetworkVersion(state);
  const products = Shop.getProducts(state);
  const placingOrder = Shop.getPlacingOrder(state);
  const placedOrder = Shop.getPlacedOrder(state);
  const placingOrderError = Shop.getPlacingOrderError(state);
  const placingOrderMessage = Shop.getPlacingOrderMessage(state);
  const orderTxHash = Shop.getOrderTxHash(state);
  const orderTxReceipt = Shop.getOrderTxReceipt(state);
  const selectedOfferId = Shop.getSelectedOfferId(state);

  return {
    networkId,
    productName,
    productSubheading,
    offerLabel,
    offers,
    logo,
    logo2x,
    tosURL,
    helpURL,
    vanityAddressPrefix,
    products,
    placingOrder,
    placedOrder,
    placingOrderError,
    placingOrderMessage,
    orderTxHash,
    orderTxReceipt,
    selectedOfferId
  };
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ ...Shop }, dispatch);
}

Offers = connect(mapStateToProps, mapDispatchToProps)(Offers);

export default styled(Offers)`
  &.form {
    padding: 1em;
    font-family: ${theme.fontFamilyMonospace};
    transition: all 0.3 ease-out;
    label {
      text-align: left;
    }

    ${FormStyles};

    &.submitting {
      background-color: #dadada;
      transition: all 0.3 ease-out;

      label {
        color: gray;
      }
    }
  }

  .infoMessage {
    background-color: #ffff93;
    padding: 1em;
    margin: 1em -6px;
    border-radius: 5px;
  }
  .warningMsg {
    background-color: #ffff93;
    padding: 1em;
    margin: 1em -6px;
    border-radius: 5px;
  }

  .help a,
  a {
    &:hover {
      text-decoration: underline;
    }
  }

  tt {
    font-size: 1.2em;
    background-color: #c1c1c1;
    padding: 0.2em 0.4em;
    border-radius: 4px;
    color: black;
  }

  .legal {
    font-size: 0.7rem;
    padding-top: 20px;
    color: #8e8e8e;
    a {
      color: #8e8e8e;
      text-decoration: none;
      &:hover {
        text-decoration: underline;
      }
    }
  }

  .errorMsg {
    word-wrap: break-word;
  }

  .trackTransaction {
    padding-top: 1em;
  }
`;
